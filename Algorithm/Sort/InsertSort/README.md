# Insert Sort

### Insert Sort란?

Insert Sort는 배열의 현재 위치 이전의 배열들은 모두 `이미 정렬이 되어 있다고 가정`하고, 자신의 위치를 찾아서 그 위치로 들어가는 정렬이다.

시행의 결과는 다음과 같다.( ` `로 표시된 숫자가 이전 배열의 값과 비교해서 자기 자리를 찾아서 들어감)

처음 배열: 
| ~~5~~ | `3` | 7 | 11 | 15 | 2 | 2 | 6 | 1 | 8 |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |

1번째 시행 후:
| 3 | 5 | ~~`7`~~ | 11 | 15 | 2 | 2 | 6 | 1 | 8 |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |

2번째 시행 후:
| 3 | 5 | 7 | ~~`11`~~ | 15 | 2 | 2 | 6 | 1 | 8 |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |

3번째 시행 후:
| 3 | 5 | 7 | 11 | ~~`15`~~ | 2 | 2 | 6 | 1 | 8 |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |

4번째 시행 후:
| ~~3~~ | 5 | 7 | 11 | 15 | `2` | 2 | 6 | 1 | 8 |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |

5번째 시행 후:
| 2 | ~~3~~ | 5 | 7 | 11 | 15 | `2` | 6 | 1 | 8 |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |

6번째 시행 후:
| 2 | 2 | 3 | 5 | ~~7~~ | 11 | 15 | `6` | 1 | 8 |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |

7번째 시행 후:
| ~~2~~ | 2 | 3 | 5 | 6 | 7 | 11 | 15 | `1` | 8 |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |

8번째 시행 후:
| 1 | 2 | 2 | 3 | 5 | 6 | 7 | ~~11~~ | 15 | `8` |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |

9번째 시행 후:
| 1 | 2 | 2 | 3 | 5 | 6 | 7 | 8 | 11 | 15 |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |


### Insert Sort Code 구현(c++)

``` cpp
//백준 2750번
#include <iostream>
using namespace std;

int main() {
	int N{};
	int check = 0;

	cin >> N;
	int a[1000];

	for (int i = 0; i < N; i++) {
		cin >> a[i];
	}

	for (int i = 1; i < N; i++) {
		for (int j = i; j > 0; j--) {
			check = 0;
			if (a[j] < a[j - 1]) {	//배열의 이전 index에 들어있는 수와 비교
				int temp = a[j];
				a[j] = a[j - 1];
				a[j - 1] = temp;
				check = 1;	// 자리를 바꿨으면 다음 숫자와도 비교를 해야함
			}
			if (!check)	// 자리가 바뀌지 않았으면 자신의 자리에 삽입이 된 것이므로 반복문을 탈출
				break;
		}
	}

	for (int i = 0; i < N; i++) {
		cout << a[i] << " ";
	}

}
```

### 시간복잡도

Insert Sort의 시간 복잡도는 이미 정렬되어 있지 않은 경우를 고려하지 않는다는 전제하에 Average Case와 Worst case의 경우에 n<sup>2</sup>으로 Bubble Sort와 Selection Sort와동일하지만 Best Case(이미 정렬이 되어있는 경우)의 경우에 자신의 자리를 찾아들어가는 과정에서 반복문이 모두 1번만에 끝나므로 시간복잡도가 n이 된다. 따라서 이미 정렬이 어느정도 되어있는 배열에서는 매우 빠르다는 특징이 있다.
