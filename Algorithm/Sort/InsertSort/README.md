# Insert Sort

### Insert Sort란?

Insert Sort는 배열의 현재 위치이 전의 배열들은 모두 `이미 정렬이 되어 있다고 가정`하고, 자신의 위치를 찾아서 그 위치로 들어가는 정렬이다.

시행의 결과는 다음과 같다.(표시된 숫자를 이전 배열의 값과 비교해서 자기 자리를 찾아서 들어감)

처음 배열: 
| 5 | `3` | 7 | 11 | 15 | 2 | 2 | 6 | 1 | 8 |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |

1번째 시행 후:
| ~~3~~ | 5 | `7` | 11 | 15 | 2 | 2 | 6 | 1 | 8 |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |

2번째 시행 후:
| 3 | 5 | ~~7~~ | `11` | 15 | 2 | 2 | 6 | 1 | 8 |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |

3번째 시행 후:
| 3 | 5 | 7 | ~~11~~ | `15` | 2 | 2 | 6 | 1 | 8 |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |

4번째 시행 후:
| 3 | 5 | 7 | 11 | ~~15~~ | `2` | 2 | 6 | 1 | 8 |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |

5번째 시행 후:
| ~~2~~ | 3 | 5 | 7 | 11 | 15 | `2` | 6 | 1 | 8 |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |

6번째 시행 후:
| 2 | ~~2~~ | 3 | 5 | 7 | 11 | 15 | `6` | 1 | 8 |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |

7번째 시행 후:
| 2 | 2 | 3 | 5 | ~~6~~ | 7 | 11 | 15 | `1` | 8 |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |

8번째 시행 후:
| ~~1~~ | 2 | 2 | 3 | 5 | 6 | 7 | 11 | 15 | `8` |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |

9번째 시행 후:
| 1 | 2 | 2 | 3 | 5 | 6 | 7 | ~8~ | 11 | 15 |
|--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |


### Bubble Sort Code 구현(c++) => 수정해야함

``` cpp
//백준 2750번
#include <iostream> 
using namespace std;

int main() {
	int N{};
	int check = 0;

	cin >> N;
	int a[1000];
	for (int i = 0; i < N; i++) {
		cin >> a[i];
	}

	for (int i = N-1; i >=  1; i--) {
		for (int j = 0; j < i; j++) {
			if (a[j] > a[j + 1]) {
				int temp = a[j];
				a[j] = a[j + 1];
				a[j + 1] = temp;
				check = 1;
			}
		}
		if (!check) //이미 정렬이 완료되어 있을 경우에 루프를 탈출한다
			break;
		check = 0;
	}

	for (int i = 0; i < N; i++) {
		cout << a[i] << endl;
	}

}
```

### 시간복잡도

Insert Sort의 시간 복잡도는 이미 정렬되어 있지 않은 경우를 고려하지 않는다는 전제하에 Average Case와 Worst case의 경우에 n<sup>2</sup>으로 Bubble Sort와 Selection Sort와동일하지만 Best Case(이미 정렬이 되어있는 경우)의 경우에 자신의 자리를 찾아들어가는 과정에서 반복문이 모두 1번만에 끝나므로 시간복잡도가 n이 된다. 따라서 이미 정렬이 어느정도 되어있는 배열에서는 매우 빠르다는 특징이 있다.
